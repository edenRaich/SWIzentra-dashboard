<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="Content-Security-Policy" content="
    default-src 'self';
    script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net https://unpkg.com;
    style-src 'self' 'unsafe-inline' https://unpkg.com;
    img-src 'self' data: https://unpkg.com https://*.tile.openstreetmap.org https://server.arcgisonline.com;
    font-src 'self' https://unpkg.com;
    connect-src 'self' https://cdn.jsdelivr.net https://unpkg.com https://zentra-proxy.onrender.com http://localhost:3000;
    object-src 'none';
    base-uri 'self';
    form-action 'self';
  ">
  <title>Down East Salt Water Intrusion Monitoring System</title>
  <!-- Leaflet CSS -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    body {
      font-family: 'Segoe UI', Arial, sans-serif;
      background: #f8fafc;
      margin: 0;
      padding: 0;
    }
    .main-title {
      font-size: 2.2em;
      font-weight: bold;
      text-align: center;
      margin: 32px 0 18px 0;
      letter-spacing: 1px;
      color: #1e293b;
    }
    .top-row {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      align-items: flex-start;
      gap: 32px;
      margin-bottom: 18px;
    }
    #map {
      width: 350px;
      height: 300px;
      border-radius: 10px;
      border: 2px solid #cbd5e1;
      box-shadow: 0 2px 8px #0001;
      margin-bottom: 0;
      background: #e0e7ef;
    }
    .blurb {
      min-width: 260px;
      max-width: 400px;
      background: #fff;
      border: 2px solid #64748b;
      border-radius: 10px;
      padding: 22px 18px;
      font-size: 1.08em;
      color: #334155;
      box-shadow: 0 2px 8px #0001;
      margin-bottom: 0;
    }
    @media (max-width: 800px) {
      .top-row {
        flex-direction: column;
        align-items: center;
      }
      #map, .blurb {
        width: 95vw;
        max-width: 98vw;
      }
    }
    .site-title { font-size: 1.2em; font-weight: bold; margin-top: 16px; }
    .sensor-chart-block { margin-bottom: 12px; }
    .sensor-title { font-weight: bold; margin-bottom: 4px; margin-top: 8px; }
    .chart-container { margin-bottom: 16px; }
    #charts { margin-top: 24px; }
    #range { margin-bottom: 12px; }
    .error-message { color: red; margin-top: 1em; }
    .controls { display: flex; gap: 12px; align-items: center; flex-wrap: wrap; }
    .loading { color: #666; margin-top: 8px; }
    .site-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
      gap: 12px;
      margin-bottom: 24px;
    }
    .miniChart {
      width: 100%;
      height: 120px !important;
      max-height: 120px;
    }
    .combinedChart {
      width: 100%;
      height: 220px !important;
      max-height: 220px;
      margin-bottom: 24px;
    }
  </style>
  <!-- Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
  <!-- Date adapter for Chart.js -->
  <script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
  <!-- Leaflet JS -->
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>
<body>
  <div class="main-title">Down East Salt Water Intrusion Monitoring System</div>
  <div class="top-row">
    <div id="map"></div>
    <div class="blurb">
      <strong>About this project:</strong><br>
      This interactive dashboard displays real-time water level, temperature, and conductivity data from monitoring sites in Down East, North Carolina. The system helps track saltwater intrusion and its impact on local ecosystems.<br><br>
      <em>Select a site on the map or from the dropdown to view detailed sensor trends.</em>
    </div>
  </div>
  <div class="controls">
    <label for="range">Show data for: </label>
    <select id="range">
      <option value="1">Past 24 hours</option>
      <option value="3">Past 3 days</option>
      <option value="7" selected>Past week</option>
    </select>
    <label for="siteSelect">Select site:</label>
    <select id="siteSelect">
      <option value="">-- Choose a site or click a marker --</option>
    </select>
    <button id="fetchSelected">Fetch selected site</button>
  </div>
  <div id="charts"><div style="color: #555; margin-top: 1em;">Click a site marker on the map (or choose from the dropdown) to load its sensor data.</div></div>

  <script>
    // Site/device info
    const sites = [
      { name: "Ghost Forest", sn: "z6-33252", lat: 34.7883175, lng: -76.4653989 },
      { name: "Murphy Cemetery", sn: "z6-33251", lat: 34.789873, lng: -76.4655548 },
      { name: "Tidal Ditch", sn: "z6-32482", lat: 34.7855122, lng: -76.4655264 },
      { name: "Styron Yard", sn: "z6-32414", lat: 34.789731, lng: -76.4612296 }
    ];

    // Brand colors per site
    const siteColors = {
      "Tidal Ditch": { line: "#1e3a8a", fill: "#1e3a8a33", marker: "#1e3a8a" }, // dark blue
      "Murphy Cemetery": { line: "#6b7280", fill: "#6b728033", marker: "#6b7280" }, // grey
      "Ghost Forest": { line: "#10b981", fill: "#10b98133", marker: "#10b981" }, // green
      "Styron Yard": { line: "#f59e0b", fill: "#f59e0b33", marker: "#f59e0b" }  // yellow
    };

    // Helper: Choose proxy URL based on environment
    const baseUrl = (window.location.hostname === 'localhost')
      ? 'http://localhost:3000'
      : 'https://zentra-proxy.onrender.com';

    const MAX_PER_PAGE = 1000000;

    // Client-side cache within the page session: { [sn]: { device, fetchedAtMs } }
    const clientCache = new Map();
    const CLIENT_CACHE_TTL_MS = 60 * 1000; // optional: mirror server cache for UX

    let lastSite = null;
    let chartInstances = [];
    let apiError = false;

    // Sensor keys to look for (case-insensitive match)
    const SENSOR_KEYS = [
      { key: "Water Level", aliases: ["Water Level", "Level"], type: "level" },
      { key: "Water Temperature", aliases: ["Water Temperature", "Temperature"], type: "temp" },
      { key: "Conductivity", aliases: ["Conductivity", "EC"], type: "ec" }
    ];

    // Conversion helpers
    function toFeet(value, unit) {
      if (unit) {
        unit = unit.toLowerCase();
        if (unit.includes("meter")) return value * 3.28084;
        if (unit.includes("centimeter") || unit === "cm") return value * 0.0328084;
        if (unit.includes("feet") || unit === "foot" || unit === "ft") return value;
      }
      return value; // fallback, assume already feet
    }
    function toFahrenheit(value, unit) {
      if (unit && unit.toLowerCase().includes("c")) return value * 9/5 + 32;
      return value;
    }
    function toMsPerInch(value, unit) {
      if (unit && unit.toLowerCase().includes("mS/cm".toLowerCase())) return value * 2.54;
      if (unit && unit.toLowerCase().includes("µs/cm")) return (value / 1000) * 2.54;
      if (unit && unit.toLowerCase().includes("ms/inch")) return value;
      return value; // fallback
    }

    // Initialize map with ArcGIS satellite tiles
    const map = L.map('map').setView([34.788, -76.464], 15);
    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
      attribution: 'Tiles © Esri'
    }).addTo(map);

    // Simple colored circle marker
    function coloredCircle(color) {
      return L.circleMarker([0,0], {
        radius: 8,
        color: color,
        weight: 2,
        fillColor: color,
        fillOpacity: 0.8
      });
    }

    // Add markers for each site with color
    sites.forEach(site => {
      const color = siteColors[site.name]?.marker || "#3b82f6";
      const marker = L.circleMarker([site.lat, site.lng], {
        radius: 8,
        color: color,
        weight: 2,
        fillColor: color,
        fillOpacity: 0.8
      }).addTo(map);
      marker.bindPopup(`<b>${site.name}</b><br>SN: ${site.sn}<br><small>Click to load data</small>`);
      marker.on('click', () => fetchAndShowSite(site));
    });

    // Populate optional dropdown
    const siteSelect = document.getElementById('siteSelect');
    sites.forEach(site => {
      const opt = document.createElement('option');
      opt.value = site.sn;
      opt.textContent = `${site.name} (${site.sn})`;
      siteSelect.appendChild(opt);
    });
    document.getElementById('fetchSelected').addEventListener('click', () => {
      const sn = siteSelect.value;
      const site = sites.find(s => s.sn === sn);
      if (site) fetchAndShowSite(site);
    });

    // Helper to filter readings by date range
    function filterReadings(readings, days) {
      const now = new Date();
      const cutoff = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
      return readings.filter(r => new Date(r.datetime) >= cutoff);
    }

    function destroyCharts() {
      chartInstances.forEach(chart => chart.destroy());
      chartInstances = [];
    }

    // Find sensor key in device.data by aliases
    function findSensorKey(data, aliases) {
      for (const key of Object.keys(data)) {
        for (const alias of aliases) {
          if (key.toLowerCase().includes(alias.toLowerCase())) return key;
        }
      }
      return null;
    }

    function renderCharts(site, device) {
      const range = document.getElementById('range').value;
      const siteColor = siteColors[site.name] || { line: '#3b82f6', fill: '#3b82f633' };

      let chartsHtml = `<div class="site-title">${site.name} (SN: ${site.sn})</div>`;
      if (!device || !device.data) {
        document.getElementById('charts').innerHTML = chartsHtml + '<div>No data available.</div>';
        return;
      }

      // Prepare per-site mini charts
      chartsHtml += `<div class="site-grid">`;
      SENSOR_KEYS.forEach(sensor => {
        const key = findSensorKey(device.data, sensor.aliases);
        if (key && Array.isArray(device.data[key]) && device.data[key].length > 0) {
          let readings = device.data[key][0].readings || [];
          const units = (device.data[key][0].metadata && device.data[key][0].metadata.units) || '';
          readings = filterReadings(readings, parseInt(range, 10));
          if (readings.length > 0) {
            const chartId = `chart-${site.sn}-${sensor.type}`;
            chartsHtml += `
              <div class="sensor-chart-block">
                <div class="sensor-title">${sensor.key} (${sensor.type === "level" ? "ft" : sensor.type === "temp" ? "°F" : "mS/inch"})</div>
                <canvas id="${chartId}" class="miniChart"></canvas>
              </div>
            `;
          }
        }
      });
      chartsHtml += `</div>`;

      // Combined charts placeholders
      chartsHtml += `
        <div class="site-title" style="margin-top:24px;">All Sites - Water Temperature (°F)</div>
        <canvas id="combined-temp" class="combinedChart"></canvas>
        <div class="site-title">All Sites - Conductivity (mS/inch)</div>
        <canvas id="combined-ec" class="combinedChart"></canvas>
      `;

      document.getElementById('charts').innerHTML = chartsHtml;

      // Render per-site mini charts (use site color)
      SENSOR_KEYS.forEach(sensor => {
        const key = findSensorKey(device.data, sensor.aliases);
        if (key && Array.isArray(device.data[key]) && device.data[key].length > 0) {
          let readings = device.data[key][0].readings || [];
          const units = (device.data[key][0].metadata && device.data[key][0].metadata.units) || '';
          readings = filterReadings(readings, parseInt(range, 10));
          if (readings.length > 0) {
            // Convert values
            let values, label;
            if (sensor.type === "level") {
              values = readings.map(r => toFeet(r.value, units));
              label = "Water Level (ft)";
            } else if (sensor.type === "temp") {
              values = readings.map(r => toFahrenheit(r.value, units));
              label = "Water Temperature (°F)";
            } else if (sensor.type === "ec") {
              values = readings.map(r => toMsPerInch(r.value, units));
              label = "Conductivity (mS/inch)";
            }
            const chartId = `chart-${site.sn}-${sensor.type}`;
            const ctx = document.getElementById(chartId).getContext('2d');
            const chart = new Chart(ctx, {
              type: 'line',
              data: {
                labels: readings.map(r => r.datetime),
                datasets: [{
                  label: label,
                  data: values,
                  fill: false,
                  borderColor: siteColor.line,
                  backgroundColor: siteColor.fill,
                  tension: 0.1,
                  pointRadius: 0
                }]
              },
              options: {
                responsive: true,
                plugins: { legend: { display: false } },
                scales: {
                  x: {
                    type: 'time',
                    time: {
                      parser: 'yyyy-MM-dd HH:mm:ssXXX',
                      tooltipFormat: 'PP HH:mm',
                      unit: 'hour',
                      displayFormats: { hour: 'MMM d, HH:mm' }
                    },
                    title: { display: false }
                  },
                  y: {
                    beginAtZero: false,
                    title: { display: false }
                  }
                },
                animation: false
              }
            });
            chartInstances.push(chart);
          }
        }
      });

      // Render combined charts for all sites
      renderCombinedCharts();
    }

    // Gather and plot combined charts for all sites (use per-site colors)
    async function renderCombinedCharts() {
      const range = document.getElementById('range').value;
      const tempDatasets = [];
      const ecDatasets = [];

      for (const site of sites) {
        const color = siteColors[site.name] || { line: '#3b82f6', fill: '#3b82f633' };

        // Try cache first
        let device = getFreshFromClientCache(site.sn);
        if (!device) {
          try {
            const { perPage, startDate } = getDateRangeParams();
            device = await fetchDeviceFromProxy(site.sn, perPage, startDate);
            clientCache.set(site.sn, { device, fetchedAtMs: Date.now() });
          } catch (e) { continue; }
        }
        // Water Temp
        const tempKey = findSensorKey(device.data, ["Water Temperature", "Temperature"]);
        if (tempKey && Array.isArray(device.data[tempKey]) && device.data[tempKey].length > 0) {
          let readings = device.data[tempKey][0].readings || [];
          const units = (device.data[tempKey][0].metadata && device.data[tempKey][0].metadata.units) || '';
          readings = filterReadings(readings, parseInt(range, 10));
          if (readings.length > 0) {
            tempDatasets.push({
              label: site.name,
              data: readings.map(r => ({ x: r.datetime, y: toFahrenheit(r.value, units) })),
              borderColor: color.line,
              backgroundColor: color.fill,
              fill: false,
              tension: 0.1,
              pointRadius: 0
            });
          }
        }
        // EC
        const ecKey = findSensorKey(device.data, ["Conductivity", "EC"]);
        if (ecKey && Array.isArray(device.data[ecKey]) && device.data[ecKey].length > 0) {
          let readings = device.data[ecKey][0].readings || [];
          const units = (device.data[ecKey][0].metadata && device.data[ecKey][0].metadata.units) || '';
          readings = filterReadings(readings, parseInt(range, 10));
          if (readings.length > 0) {
            ecDatasets.push({
              label: site.name,
              data: readings.map(r => ({ x: r.datetime, y: toMsPerInch(r.value, units) })),
              borderColor: color.line,
              backgroundColor: color.fill,
              fill: false,
              tension: 0.1,
              pointRadius: 0
            });
          }
        }
      }

      // Water Temp Combined Chart
      const tempCtx = document.getElementById('combined-temp').getContext('2d');
      chartInstances.push(new Chart(tempCtx, {
        type: 'line',
        data: { datasets: tempDatasets },
        options: {
          responsive: true,
          plugins: { legend: { display: true } },
          scales: {
            x: {
              type: 'time',
              time: {
                parser: 'yyyy-MM-dd HH:mm:ssXXX',
                tooltipFormat: 'PP HH:mm',
                unit: 'hour',
                displayFormats: { hour: 'MMM d, HH:mm' }
              },
              title: { display: true, text: 'Timestamp' }
            },
            y: {
              beginAtZero: false,
              title: { display: true, text: 'Water Temperature (°F)' }
            }
          },
          animation: false
        }
      }));

      // EC Combined Chart
      const ecCtx = document.getElementById('combined-ec').getContext('2d');
      chartInstances.push(new Chart(ecCtx, {
        type: 'line',
        data: { datasets: ecDatasets },
        options: {
          responsive: true,
          plugins: { legend: { display: true } },
          scales: {
            x: {
              type: 'time',
              time: {
                parser: 'yyyy-MM-dd HH:mm:ssXXX',
                tooltipFormat: 'PP HH:mm',
                unit: 'hour',
                displayFormats: { hour: 'MMM d, HH:mm' }
              },
              title: { display: true, text: 'Timestamp' }
            },
            y: {
              beginAtZero: false,
              title: { display: true, text: 'Conductivity (mS/inch)' }
            }
          },
          animation: false
        }
      }));
    }

    function showApiError(message) {
      document.getElementById('charts').innerHTML =
        `<div class="error-message">
          ${message || 'Unable to load data from Zentra API (call limit reached or network error).'}
          <br>Please try again later.
        </div>`;
    }

    function showLoading(site) {
      document.getElementById('charts').innerHTML =
        `<div class="site-title">${site.name} (SN: ${site.sn})</div>
         <div class="loading">Loading data...</div>`;
    }

    // Build query and fetch for a single device
    async function fetchDeviceFromProxy(sn, perPage, startDate) {
      const params = new URLSearchParams();
      params.set('device_sn', sn);
      if (perPage) params.set('per_page', perPage);
      if (startDate) params.set('start_date', startDate);

      const url = `${baseUrl}/zentra?${params.toString()}`;
      const res = await fetch(url);
      if (!res.ok) {
        const text = await res.text().catch(() => '');
        throw new Error(`Proxy error ${res.status}: ${text}`);
      }
      const json = await res.json();
      if (!json || !Array.isArray(json.devices) || json.devices.length === 0) {
        throw new Error('No device data returned');
      }
      const device = json.devices[0];
      if (device && device.error) {
        throw new Error(`Zentra error for ${device.device_sn}: ${device.status} - ${device.body}`);
      }
      return device;
    }

    function getDateRangeParams() {
      const days = parseInt(document.getElementById('range').value, 10);
      const now = new Date();
      const start = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
      const startDate = start.toISOString().slice(0, 10); // API expects YYYY-MM-DD
      return { perPage: MAX_PER_PAGE, startDate };
    }

    function getFreshFromClientCache(sn) {
      const entry = clientCache.get(sn);
      if (!entry) return null;
      if (Date.now() - entry.fetchedAtMs < CLIENT_CACHE_TTL_MS) return entry.device;
      clientCache.delete(sn);
      return null;
    }

    async function fetchAndShowSite(site) {
      lastSite = site;
      destroyCharts();

      // Show cached device quickly if fresh (optional UX)
      const cached = getFreshFromClientCache(site.sn);
      if (cached) {
        renderCharts(site, cached);
        // Also kick a background refresh in case server cache expired
        backgroundRefresh(site);
        return;
      }

      showLoading(site);
      try {
        const { perPage, startDate } = getDateRangeParams();
        const device = await fetchDeviceFromProxy(site.sn, perPage, startDate);
        clientCache.set(site.sn, { device, fetchedAtMs: Date.now() });
        renderCharts(site, device);
      } catch (err) {
        apiError = true;
        console.error(err);
        showApiError(err.message);
      }
    }

    // Background refresh: re-fetch silently and update view if still on same site
    async function backgroundRefresh(site) {
      try {
        const { perPage, startDate } = getDateRangeParams();
        const device = await fetchDeviceFromProxy(site.sn, perPage, startDate);
        clientCache.set(site.sn, { device, fetchedAtMs: Date.now() });
        if (lastSite && lastSite.sn === site.sn) {
          destroyCharts();
          renderCharts(site, device);
        }
      } catch (e) {
        // Swallow background errors to avoid UX flicker
        console.warn('Background refresh failed:', e.message);
      }
    }

    // When range changes, if a site is selected, refetch that site (so server-side cache respects new time window)
    document.getElementById('range').addEventListener('change', () => {
      if (!lastSite) return;
      clientCache.delete(lastSite.sn);
      fetchAndShowSite(lastSite);
    });

    // Optionally, choose an initial site to show by default:
    // fetchAndShowSite(sites[0]);
  </script>
</body>
</html>
