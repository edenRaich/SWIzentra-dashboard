<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <title>Down East Salt Water Intrusion Monitoring System</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <style>
        html,
        body {
            max-width: 100vw;
            overflow-x: hidden;
        }

        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            background: #082567;
            margin: 0;
            padding: 0;
        }

        .banner-header {
            width: 100%;
            height: 200px;
            background: url('TitleImage.png') center center/cover no-repeat;
            display: flex;
            align-items: flex-start;
            justify-content: flex-start;
            position: relative;
            margin-bottom: 30px;
            padding: 0 40px;
            box-sizing: border-box;
        }

        .banner-title {
            font-size: 2.8rem;
            color: #02590f;
            font-weight: bold;
            margin: 0;
            padding: 0;
            border: none;
            background: none;
            text-shadow: 2px 2px 8px rgba(255, 255, 255, 0.2);
            letter-spacing: 1px;
            flex: 0 1 auto;
            text-align: left;
            align-self: flex-start;
            margin-top: 28px;
            margin-right: 18px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            max-width: 80vw;
        }

        .banner-logo {
            height: 110px;
            background: none;
            box-shadow: none;
            border: none;
            align-self: flex-start;
            margin-top: 32px;
            margin-left: 60px;
        }

        @media (max-width: 900px) {
            .banner-title {
                font-size: 1.5rem;
                max-width: 60vw;
            }

            .banner-header {
                height: 120px;
                padding: 0 10px;
            }

            .banner-logo {
                height: 60px;
                margin-top: 20px;
                margin-left: 20px;
            }
        }

        .dashboard-row {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            gap: 0;
            margin-bottom: 18px;
            width: 100%;
            box-sizing: border-box;
            padding-left: 24px;
            padding-right: 24px;
        }

        .map-blurb-row {
            display: flex;
            flex-direction: row;
            align-items: flex-start;
            width: 100%;
        }

        .main-content {
            display: flex;
            flex-direction: column;
            align-items: flex-start;
            flex: 1 1 auto;
        }

        #map {
            width: 800px;
            height: 500px;
            border-radius: 10px;
            box-shadow: 0 2px 8px #0001;
            background: #fff;
            margin-bottom: 24px;
            border: none;
            box-sizing: border-box;
            min-width: 320px;
            max-width: 100%;
        }

        .blurb-box {
            min-width: 220px;
            max-width: 340px;
            background: #c9dc87;
            border: 3px solid #c9dc87;
            border-radius: 12px;
            padding: 18px 14px 14px 14px;
            font-size: 1.08em;
            color: #134e4a;
            box-shadow: 0 2px 8px #0001;
            min-height: 320px;
            height: 100%;
            margin-left: 24px;
            margin-top: 0;
            margin-bottom: 18px;
            position: relative;
            box-sizing: border-box;
            word-break: break-word;
            overflow-wrap: break-word;
            align-self: flex-start;
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
        }

        .blurb-label {
            font-size: 2.8rem;
            color: #02590f;
            font-weight: bold;
            margin: 0;
            padding: 0;
            background: none;
            border: none;
            letter-spacing: 1px;
            align-self: flex-start;
        }

        @media (max-width: 1200px) {
            #map {
                width: 98vw;
            }

            .main-content {
                margin-left: 0;
            }

            .blurb-box {
                margin-left: 0;
                margin-top: 24px;
            }

            .map-blurb-row {
                flex-direction: column;
                align-items: center;
            }
        }

        .controls {
            display: flex;
            gap: 12px;
            align-items: center;
            flex-wrap: wrap;
            margin-bottom: 18px;
            padding-left: 8px;
            padding-right: 8px;
        }

        .controls label {
            color: #c9dc87;
            font-weight: bold;
            font-size: 1.1em;
        }

        .combined-charts-row {
            display: flex;
            flex-direction: row;
            gap: 32px;
            justify-content: center;
            align-items: flex-start;
            width: 100%;
            margin-bottom: 32px;
            padding-left: 24px;
            padding-right: 24px;
            box-sizing: border-box;
        }

        .combinedChart {
            width: 600px;
            height: 300px !important;
            background: #fff;
            border-radius: 12px;
            border: none;
            box-sizing: border-box;
        }

        .chart-label,
        .site-title {
            font-size: 1.5em;
            font-weight: bold;
            margin-top: 16px;
            margin-bottom: 8px;
            text-align: center;
            background: transparent;
            color: #c9dc87 !important;
            letter-spacing: 0.5px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        #perSiteCharts {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
        }

        .site-grid {
            display: flex;
            flex-direction: row;
            justify-content: center;
            align-items: flex-start;
            gap: 32px;
            margin-bottom: 24px;
            width: 100%;
            padding-left: 24px;
            padding-right: 24px;
            box-sizing: border-box;
        }

        .miniChart {
            width: 400px;
            height: 220px !important;
            background: #fff;
            border-radius: 12px;
            border: none;
        }

        .sensor-chart-block {
            margin-bottom: 12px;
        }

        .sensor-title {
            font-size: 1.5em;
            font-weight: bold;
            color: #c9dc87;
            margin-bottom: 4px;
            margin-top: 8px;
            text-align: center;
            letter-spacing: 0.5px;
        }

        .error-message {
            color: red;
            margin-top: 1em;
        }

        .loading {
            color: #555;
            margin-top: 8px;
        }

        #charts {
            margin-top: 24px;
            padding-left: 8px;
            padding-right: 8px;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>
    <script
        src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js">
    </script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
</head>

<body>
    <!-- Banner Header -->
    <div class="banner-header">
        <h1 class="banner-title">Down East Salt Water Intrusion Monitoring System</h1>
        <img src="Logo.png" alt="Logo" class="banner-logo">
    </div>
    <div class="dashboard-row">
        <div class="main-content">
            <div class="map-blurb-row">
                <div id="map"></div>
                <div class="blurb-box">
                    <span class="blurb-label">Blurb</span>
                </div>
            </div>
            <div class="controls">
                <label for="range">Show data for: </label>
                <select id="range">
                    <option value="1">Past 24 hours</option>
                    <option value="3">Past 3 days</option>
                    <option value="7" selected>Past week</option>
                </select>
                <label for="siteSelect">Select site:</label>
                <select id="siteSelect">
                    <option value="">-- Choose a site or click a marker --</option>
                </select>
                <button id="fetchSelected">Show selected site</button>
                <span id="lastUpdated" style="color:#64748b;"></span>
            </div>
            <div class="combined-charts-row">
                <div style="display:flex;flex-direction:column;">
                    <div class="chart-label">All Sites - Water Level (ft)</div>
                    <canvas id="combined-level" class="combinedChart"></canvas>
                </div>
                <div style="display:flex;flex-direction:column;">
                    <div class="chart-label">All Sites - Conductivity (mS/inch)</div>
                    <canvas id="combined-ec" class="combinedChart"></canvas>
                </div>
            </div>
            <div id="perSiteCharts"></div>
        </div>
    </div>
    <div id="charts">
        <div class="loading" id="loadingMessage">Loading all sites...</div>
    </div>
    <script>
        // SN to scientific name mapping
        const snToSci = {
            "z6-33252": "GF2501",
            "z6-33251": "MC2501",
            "z6-32482": "MD2501",
            "z6-32414": "ML2501"
        };
        // Sites list with your colors and scientific names
        const sites = [
            { name: "Tidal Ditch", sn: "z6-32482", sci: snToSci["z6-32482"], lat: 34.7855122, lng: -76.4655264, color: "#1e3a8a" },
            { name: "Murphy Cemetery", sn: "z6-33251", sci: snToSci["z6-33251"], lat: 34.789873, lng: -76.4655548, color: "#6b7280" },
            { name: "Ghost Forest", sn: "z6-33252", sci: snToSci["z6-33252"], lat: 34.7883175, lng: -76.4653989, color: "#10b981" },
            { name: "Styron Yard", sn: "z6-32414", sci: snToSci["z6-32414"], lat: 34.789731, lng: -76.4612296, color: "#f59e0b" }
        ];
        // Proxy base URL
        const baseUrl = (window.location.hostname === 'localhost') ? 'http://localhost:3000' : 'https://zentra-proxy.onrender.com';
        const MAX_PER_PAGE = 1000000;
        let allDevices = {};
        let lastSite = null;
        let perSiteChartInstances = [];
        let combinedChartInstances = [];
        const SENSOR_KEYS = [
            { key: "Water Level", aliases: ["Water Level", "Level"], type: "level" },
            { key: "Water Temperature", aliases: ["Water Temperature", "Temperature"], type: "temp" },
            { key: "Conductivity", aliases: ["Conductivity", "EC"], type: "ec" }
        ];
        function toFeet(value, unit) {
            if (!unit) return value;
            const u = unit.toLowerCase();
            if (u.includes("meter")) return value * 3.28084;
            if (u.includes("centimeter") || u === "cm") return value * 0.0328084;
            if (u.includes("feet") || u === "foot" || u === "ft") return value;
            return value;
        }
        function toFahrenheit(value, unit) {
            if (!unit) return value;
            const u = unit.toLowerCase();
            if (u.startsWith("c")) return value * 9 / 5 + 32;
            return value;
        }
        function toMsPerInch(value, unit) {
            if (!unit) return value;
            const u = unit.toLowerCase();
            if (u.includes("ms/cm")) return value * 2.54;
            if (u.includes("µs/cm") || u.includes("us/cm")) return (value / 1000) * 2.54;
            if (u.includes("ms/inch")) return value;
            return value;
        }
        function destroyCharts(chartArray) {
            chartArray.forEach(c => { try { c.destroy(); } catch (e) { } });
            chartArray.length = 0;
        }
        // Map with ArcGIS imagery and original markers
        const map = L.map('map').setView([34.788, -76.464], 15);
        L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
            attribution: 'Tiles © Esri'
        }).addTo(map);
        // Add markers and hover/click handlers
        sites.forEach(site => {
            const marker = L.marker([site.lat, site.lng]).addTo(map);
            marker.bindPopup(`<b>${site.name}</b><br>${site.sci}`);
            marker.on('mouseover', function (e) { this.openPopup(); });
            marker.on('mouseout', function (e) { this.closePopup(); });
            marker.on('click', () => {
                showPerSiteCharts(site.sn);
                document.getElementById('siteSelect').value = site.sn;
                document.getElementById('perSiteCharts').scrollIntoView({ behavior: 'smooth', block: 'start' });
            });
        });
        // Populate dropdown
        const siteSelect = document.getElementById('siteSelect');
        sites.forEach(site => {
            const opt = document.createElement('option');
            opt.value = site.sn;
            opt.textContent = `${site.name} (${site.sci})`;
            siteSelect.appendChild(opt);
        });
        document.getElementById('fetchSelected').addEventListener('click', () => {
            const sn = siteSelect.value;
            if (sn) showPerSiteCharts(sn);
        });
        function getDateRangeParams() {
            const days = parseInt(document.getElementById('range').value, 10);
            const now = new Date();
            const start = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
            const startDate = start.toISOString().slice(0, 10);
            return { perPage: MAX_PER_PAGE, startDate };
        }
        function filterReadings(readings, days) {
            const now = new Date();
            const cutoff = new Date(now.getTime() - days * 24 * 60 * 60 * 1000);
            return readings.filter(r => new Date(r.datetime) >= cutoff);
        }
        function findSensorKey(data, aliases) {
            for (const key of Object.keys(data)) {
                for (const a of aliases) {
                    if (key.toLowerCase().includes(a.toLowerCase())) return key;
                }
            }
            return null;
        }
        function showPerSiteCharts(sn) {
            const site = sites.find(s => s.sn === sn);
            lastSite = sn;
            const device = allDevices[sn];
            destroyCharts(perSiteChartInstances);
            let html = `<div class="chart-label" style="color:${site.color}">${site.name} (${site.sci})</div>`;
            if (!device || !device.data) {
                document.getElementById('perSiteCharts').innerHTML = html + '<div>No data available.</div>';
                return;
            }
            html += `<div class="site-grid">`;
            const rangeDays = parseInt(document.getElementById('range').value, 10);
            SENSOR_KEYS.forEach(sensor => {
                const key = findSensorKey(device.data, sensor.aliases);
                if (!key || !Array.isArray(device.data[key]) || device.data[key].length === 0) return;
                let readings = device.data[key][0].readings || [];
                const units = (device.data[key][0].metadata && device.data[key][0].metadata.units) || '';
                readings = filterReadings(readings, rangeDays);
                if (readings.length === 0) return;
                const chartId = `chart-${site.sn}-${sensor.type}`;
                html += `
          <div class="sensor-chart-block">
            <div class="sensor-title">
              ${sensor.type === "level" ? "Water Level (ft)" : sensor.type === "temp" ? "Water Temperature (°F)" : "Conductivity (mS/inch)"}
            </div>
            <canvas id="${chartId}" class="miniChart"></canvas>
          </div>
        `;
            });
            html += `</div>`;
            document.getElementById('perSiteCharts').innerHTML = html;
            SENSOR_KEYS.forEach(sensor => {
                const key = findSensorKey(device.data, sensor.aliases);
                if (!key || !Array.isArray(device.data[key]) || device.data[key].length === 0) return;
                let readings = device.data[key][0].readings || [];
                const units = (device.data[key][0].metadata && device.data[key][0].metadata.units) || '';
                readings = filterReadings(readings, rangeDays);
                if (readings.length === 0) return;
                let values, label;
                if (sensor.type === "level") {
                    values = readings.map(r => toFeet(r.value, units));
                    label = "Water Level (ft)";
                } else if (sensor.type === "temp") {
                    values = readings.map(r => toFahrenheit(r.value, units));
                    label = "Water Temperature (°F)";
                } else {
                    values = readings.map(r => toMsPerInch(r.value, units));
                    label = "Conductivity (mS/inch)";
                }
                const ctx = document.getElementById(`chart-${site.sn}-${sensor.type}`)?.getContext('2d');
                if (!ctx) return;
                const chart = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: readings.map(r => r.datetime),
                        datasets: [{
                            label,
                            data: values,
                            fill: false,
                            borderColor: site.color,
                            backgroundColor: site.color + "33",
                            borderWidth: 1,
                            tension: 0.1,
                            pointRadius: 0
                        }]
                    },
                    options: {
                        responsive: true,
                        plugins: { legend: { display: false } },
                        scales: {
                            x: {
                                type: 'time',
                                time: {
                                    parser: 'yyyy-MM-dd HH:mm:ssXXX',
                                    tooltipFormat: 'PP HH:mm',
                                    unit: 'hour',
                                    displayFormats: { hour: 'MMM d, HH:mm' }
                                }
                            },
                            y: { beginAtZero: false }
                        },
                        animation: false
                    }
                });
                perSiteChartInstances.push(chart);
            });
        }
        function renderCombinedCharts() {
            destroyCharts(combinedChartInstances);
            const levelCtx = document.getElementById('combined-level').getContext('2d');
            const ecCtx = document.getElementById('combined-ec').getContext('2d');
            const range = parseInt(document.getElementById('range').value, 10);
            const levelDatasets = [];
            const ecDatasets = [];
            sites.forEach(site => {
                const device = allDevices[site.sn];
                if (!device || !device.data) return;
                const lKey = findSensorKey(device.data, ["Water Level", "Level"]);
                if (lKey && Array.isArray(device.data[lKey]) && device.data[lKey].length > 0) {
                    let readings = device.data[lKey][0].readings || [];
                    const units = (device.data[lKey][0].metadata && device.data[lKey][0].metadata.units) || '';
                    readings = filterReadings(readings, range);
                    if (readings.length > 0) {
                        levelDatasets.push({
                            label: site.name + " (" + site.sci + ")",
                            data: readings.map(r => ({ x: r.datetime, y: toFeet(r.value, units) })),
                            borderColor: site.color,
                            backgroundColor: site.color + "33",
                            borderWidth: 1,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0
                        });
                    }
                }
                const eKey = findSensorKey(device.data, ["Conductivity", "EC"]);
                if (eKey && Array.isArray(device.data[eKey]) && device.data[eKey].length > 0) {
                    let readings = device.data[eKey][0].readings || [];
                    const units = (device.data[eKey][0].metadata && device.data[eKey][0].metadata.units) || '';
                    readings = filterReadings(readings, range);
                    if (readings.length > 0) {
                        ecDatasets.push({
                            label: site.name + " (" + site.sci + ")",
                            data: readings.map(r => ({ x: r.datetime, y: toMsPerInch(r.value, units) })),
                            borderColor: site.color,
                            backgroundColor: site.color + "33",
                            borderWidth: 1,
                            fill: false,
                            tension: 0.1,
                            pointRadius: 0
                        });
                    }
                }
            });
            const levelChart = new Chart(levelCtx, {
                type: 'line',
                data: { datasets: levelDatasets },
                options: {
                    responsive: true,
                    plugins: { legend: { display: true } },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                parser: 'yyyy-MM-dd HH:mm:ssXXX',
                                tooltipFormat: 'PP HH:mm',
                                unit: 'hour',
                                displayFormats: { hour: 'MMM d, HH:mm' }
                            },
                            title: { display: true, text: 'Timestamp' }
                        },
                        y: { beginAtZero: false, title: { display: true, text: 'Water Level (ft)' } }
                    },
                    animation: false
                }
            });
            const ecChart = new Chart(ecCtx, {
                type: 'line',
                data: { datasets: ecDatasets },
                options: {
                    responsive: true,
                    plugins: { legend: { display: true } },
                    scales: {
                        x: {
                            type: 'time',
                            time: {
                                parser: 'yyyy-MM-dd HH:mm:ssXXX',
                                tooltipFormat: 'PP HH:mm',
                                unit: 'hour',
                                displayFormats: { hour: 'MMM d, HH:mm' }
                            },
                            title: { display: true, text: 'Timestamp' }
                        },
                        y: { beginAtZero: false, title: { display: true, text: 'Conductivity (mS/inch)' } }
                    },
                    animation: false
                }
            });
            combinedChartInstances.push(levelChart, ecChart);
        }
        function showApiError(message) {
            document.getElementById('loadingMessage').textContent = '';
            document.getElementById('perSiteCharts').innerHTML = '';
            document.getElementById('combinedCharts').innerHTML = `
        <div class="error-message">
          ${message || 'Unable to load data from Zentra API (limit reached or network error).'}
        </div>`;
        }
        async function fetchDeviceFromProxy(sn, perPage, startDate) {
            const params = new URLSearchParams();
            params.set('device_sn', sn);
            if (perPage) params.set('per_page', perPage);
            if (startDate) params.set('start_date', startDate);
            const url = `${baseUrl}/zentra?${params.toString()}`;
            const res = await fetch(url);
            if (!res.ok) {
                const text = await res.text().catch(() => '');
                throw new Error(`Proxy error ${res.status}: ${text}`);
            }
            const json = await res.json();
            if (!json || !Array.isArray(json.devices) || json.devices.length === 0) {
                throw new Error('No device data returned');
            }
            const device = json.devices[0];
            if (device && device.error) {
                throw new Error(`Zentra error for ${device.device_sn}: ${device.status} - ${device.body}`);
            }
            return device;
        }
        async function loadAllSites() {
            document.getElementById('loadingMessage').textContent = 'Loading all sites...';
            document.getElementById('perSiteCharts').innerHTML = '';
            destroyCharts(perSiteChartInstances);
            allDevices = {};
            const { perPage, startDate } = getDateRangeParams();
            try {
                await Promise.all(sites.map(async site => {
                    try {
                        const device = await fetchDeviceFromProxy(site.sn, perPage, startDate);
                        allDevices[site.sn] = device;
                    } catch (e) {
                        allDevices[site.sn] = null;
                        console.warn('Failed to load', site.sn, e);
                    }
                }));
            } catch (e) {
                showApiError(e.message);
                return;
            }
            renderCombinedCharts();
            const ts = new Date().toLocaleString();
            document.getElementById('lastUpdated').textContent = `Data loaded: ${ts}`;
            if (lastSite) showPerSiteCharts(lastSite);
            document.getElementById('loadingMessage').textContent = '';
        }
        document.getElementById('range').addEventListener('change', () => {
            loadAllSites();
        });
        loadAllSites();
    </script>
</body>

</html>
