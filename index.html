<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Zentra Dashboard - Tabs by Site</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body { font-family: sans-serif; background: #f8f8f8; }
    .container { width: 900px; margin: 40px auto; }
    h1 { text-align: center; }
    .tabs { display: flex; border-bottom: 2px solid #ccc; margin-bottom: 20px; }
    .tab {
      padding: 12px 24px;
      cursor: pointer;
      background: #eee;
      border: none;
      border-radius: 8px 8px 0 0;
      margin-right: 4px;
      font-size: 1.1em;
      transition: background 0.2s;
    }
    .tab.active { background: #fff; border-bottom: 2px solid #fff; font-weight: bold; }
    .tab-content { display: none; }
    .tab-content.active { display: block; }
    .chart-block { margin-bottom: 40px; background: #fff; border-radius: 8px; box-shadow: 0 2px 8px #0001; padding: 20px; }
    .chart-title { text-align: center; margin-bottom: 10px; }
  </style>
</head>
<body>
  <div class="container">
    <h1>Zentra Site Sensor Dashboard</h1>
    <div class="tabs" id="tabs"></div>
    <div id="tab-contents"></div>
  </div>
  <script>
    const siteNameMapping = {
      "z6-33252": "Ghost Forest",
      "z6-33251": "Murphy Cemetery",
      "z6-32482": "Nibble Fish Corner",
      "z6-32414": "B & K Styron Yard"
    };
    const deviceSNs = Object.keys(siteNameMapping);

    function getRandomColor() {
      const r = Math.floor(Math.random() * 200) + 30;
      const g = Math.floor(Math.random() * 200) + 30;
      const b = Math.floor(Math.random() * 200) + 30;
      return `rgba(${r},${g},${b},0.7)`;
    }

    fetch('https://zentra-proxy.onrender.com/zentra?' + deviceSNs.map(sn => `device_sn=${sn}`).join('&'))
      .then(res => res.json())
      .then(devices => {
        console.log("Fetched devices (raw):", devices);
        devices = devices.filter(device => device && !device.error && device.data);
        if (!devices.length) {
          alert("No valid device data available. Check API or network.");
          return;
        }

        // Build tabs
        const tabsDiv = document.getElementById('tabs');
        const tabContentsDiv = document.getElementById('tab-contents');
        tabsDiv.innerHTML = '';
        tabContentsDiv.innerHTML = '';

        devices.forEach((device, idx) => {
          const siteName = siteNameMapping[device.device_sn] || device.device_sn;

          // Create tab button
          const tabBtn = document.createElement('button');
          tabBtn.className = 'tab' + (idx === 0 ? ' active' : '');
          tabBtn.textContent = siteName;
          tabBtn.dataset.tab = `tab-${device.device_sn}`;
          tabsDiv.appendChild(tabBtn);

          // Create tab content
          const tabContent = document.createElement('div');
          tabContent.className = 'tab-content' + (idx === 0 ? ' active' : '');
          tabContent.id = `tab-${device.device_sn}`;

          // For each sensor/port, create a chart
          Object.keys(device.data).forEach(sensorType => {
            const sensorArr = device.data[sensorType];
            if (!sensorArr || !sensorArr.length || !sensorArr[0].readings) return;
            const readings = sensorArr[0].readings;
            const sortedReadings = readings.slice().sort((a, b) => a.datetime.localeCompare(b.datetime));
            const labels = sortedReadings.map(r => r.datetime);
            const data = sortedReadings.map(r => r.value);

            // Chart block
            const chartBlock = document.createElement('div');
            chartBlock.className = 'chart-block';
            const chartTitle = document.createElement('div');
            chartTitle.className = 'chart-title';
            chartTitle.textContent = sensorType;
            const canvas = document.createElement('canvas');
            chartBlock.appendChild(chartTitle);
            chartBlock.appendChild(canvas);
            tabContent.appendChild(chartBlock);

            // Render chart
            new Chart(canvas.getContext('2d'), {
              type: 'line',
              data: {
                labels: labels,
                datasets: [{
                  label: sensorType,
                  data: data,
                  fill: false,
                  borderColor: getRandomColor(),
                  backgroundColor: getRandomColor(),
                  tension: 0.1
                }]
              },
              options: {
                responsive: true,
                plugins: {
                  legend: { display: false },
                  title: { display: false }
                },
                scales: {
                  x: { title: { display: true, text: 'Datetime' } },
                  y: { title: { display: true, text: 'Value' }, beginAtZero: false }
                }
              }
            });
          });

          tabContentsDiv.appendChild(tabContent);
        });

        // Tab switching logic
        tabsDiv.addEventListener('click', function(e) {
          if (e.target.classList.contains('tab')) {
            document.querySelectorAll('.tab').forEach(tab => tab.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(tc => tc.classList.remove('active'));
            e.target.classList.add('active');
            document.getElementById(e.target.dataset.tab).classList.add('active');
          }
        });
      })
      .catch(err => {
        alert("Error fetching or processing data. See console for details.");
        console.error("Error fetching or processing data:", err);
      });
  </script>
</body>
</html>
